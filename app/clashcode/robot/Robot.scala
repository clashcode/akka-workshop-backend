package clashcode.robot

import scala.util.Random

/** a robot
  * represented by its genetic code and its fitness (points)
  *
  * code: the genetic code of the robot
  * points: the fitness of the robot (how many points did it score?)
  */
case class Robot(code: RobotCode, points: Int)

/** the genetic code (128 bytes with values 0 to 5) that represents the decisions of the robot in all 128 situations.
  * also has additional metadata:
  *
  * creatorName: who created this code?
  * generations: creators and their number of generations contributed to this robot code
  * */
case class RobotCode(code: Array[Byte], creatorName: String, generations: Map[String, Int]) {

  if (code.length != Situations.count) throw new IllegalArgumentException("Length of code must be " + Situations.count)

  /** generation of this code */
  def generation : Int = generations.map(_._2).sum

  /** evaluate this code. returns a robot with its calculated fitness.
    *
    * creatorName: please provide your name so we know who created this robot
    * parents: please provide the parents of this robots so we can track its genetic history */
  def evaluate : Robot = {

    // get the fitness of this robot code
    val decisions = toDecisions
    val points = Evaluator.evaluate(decisions).points

    Robot(this, points)
  }

  /** get decisions from this code */
  private def toDecisions : IndexedSeq[Decision] = {
    try {
      code.map(decisionIndex => Decisions.all(decisionIndex))
    }
    catch {
      case ex: IndexOutOfBoundsException =>
        throw new IllegalArgumentException("Invalid robot code found. Please make sure your generated byte array consists of values from 0 to 5")
    }
  }
}

object RobotCode {

  /** create a new robot code from a genetic code represented as a Byte array (128 bytes with values 0 to 5)
    * The code represents the decisions of the robot in all 128 situations.
    *
    * additional required metadata:
    *
    * creatorName: your name
    * parents: parent codes from which you created this code
    * */
  def apply(code: Array[Byte], creatorName: String, parents: Seq[RobotCode]) = {

    // merge old generation info of parents into new generations info (sorry for bad style)
    val creatorGenerations = (parents.map(_.generations.getOrElse(creatorName, 0)) :+ 0).max
    val previousGenerations = parents.flatMap(_.generations.toSeq) :+ (creatorName, creatorGenerations + 1)
    val newGenerations = previousGenerations.groupBy(_._1).map(gen => (gen._1, gen._2.map(_._2).max))

    new RobotCode(code, creatorName, newGenerations)
  }

  /** create random robot code with given creators name */
  def createRandomCode(creatorName: String) : RobotCode = {
    val randomCode = Array.fill(Situations.count)(Random.nextInt(Decisions.count).toByte)
    RobotCode(randomCode, creatorName, Seq.empty)
  }


}